{"version":11,"variables":[{"key":"service","type":"query","input":"fetch dt.entity.service\n| fields entity.name","multiple":true}],"tiles":{"0":{"type":"code","title":"Request Count (Throughput)","input":"/*\n * This function will run in the DYNATRACE JavaScript runtime.\n * For information, visit https://dt-url.net/functions-help\n */\nimport { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function fetchMetricResults() {\n  const serviceSelection = $service;\n  const metricKey = \"builtin:service.requestCount.total\";\n\n  const config = {\n    metricSelector: buildQuery(serviceSelection, metricKey),\n    resolution: \"Inf\",\n    from: $dt_timeframe_from,\n    to: $dt_timeframe_to,\n    acceptType: \"application/json; charset=utf-8\"\n  };\n\n  if (config.metricSelector.length > 3500) {\n    return \"Please select fewer services\";\n  }\n\n  const metricQuery = await metricsClient.query(config);\n\n  const processedResults = metricQuery.result[0].data.map(result => {\n    return {\n      \"Service Name\": result.dimensionMap[\"dt.entity.service.name\"],\n      \"Service ID\": result.dimensionMap[\"dt.entity.service\"],\n      \"Request Count\": result.values\n    };\n  });\n\n  return processedResults;\n}\n\nfunction buildQuery(inputs: string[], metricKey: string): string {\n  const filters = inputs.map(\n    input => `in(\"dt.entity.service\", entitySelector(\"type(service), entityName.equals(~\"${input}~\")\"))`\n  );\n  const filterString = filters.join(\",\");\n\n  return `${metricKey}:filter(or(${filterString})):splitBy(\"dt.entity.service\"):sort(value(auto, descending)):names`;\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"","autoscale":true},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"1":{"type":"code","title":"Average Response Time (ms)","input":"/*\n * This function will run in the DYNATRACE JavaScript runtime.\n * For information visit https://dt-url.net/functions-help\n */\nimport { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function fetchMetricResults() {\n  const serviceSelection = $service;\n  const metricKey = \"builtin:service.response.time\";\n\n  const config = {\n    metricSelector: buildQuery(serviceSelection, metricKey),\n    resolution: \"Inf\",\n    from: $dt_timeframe_from,\n    to: $dt_timeframe_to,\n    acceptType: \"application/json; charset=utf-8\"\n  };\n\n  if (config.metricSelector.length > 3500) {\n    return \"Please select fewer services\";\n  }\n\n  const metricQuery = await metricsClient.query(config);\n\n  const processedResults: MetricResult[] = metricQuery.result[0].data.map(result => {\n    return {\n      \"Service Name\": result.dimensionMap[\"dt.entity.service.name\"],\n      \"Service ID\": result.dimensionMap[\"dt.entity.service\"],\n      \"Avg Response Time (Ms)\": result.values / 1000\n    };\n  });\n\n  return processedResults;\n}\n\nfunction buildQuery(inputs: string[], metricKey: string): string {\n  const filters = inputs.map(\n    input => `in(\"dt.entity.service\", entitySelector(\"type(service), entityName.equals(~\"${input}~\")\"))`\n  );\n  const filterString = filters.join(\",\");\n\n  return `${metricKey}:filter(or(${filterString})):splitBy(\"dt.entity.service\"):sort(value(auto,descending)):names`;\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"","autoscale":true},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[["service_name"]]}}},"6":{"type":"code","title":"Error Rate (Failures)","input":"/*\n * This function will run in the DYNATRACE JavaScript runtime.\n * For information, visit https://dt-url.net/functions-help\n */\nimport { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function fetchMetricResults() {\n  const serviceSelection = $service;\n  const metricKey = \"builtin:service.errors.total.rate\";\n\n  const config = {\n    metricSelector: buildQuery(serviceSelection, metricKey),\n    resolution: \"Inf\",\n    from: $dt_timeframe_from,\n    to: $dt_timeframe_to,\n    acceptType: \"application/json; charset=utf-8\"\n  };\n\n  if (config.metricSelector.length > 3500) {\n    return \"Please select fewer services\";\n  }\n\n  const metricQuery = await metricsClient.query(config);\n\n  const processedResults: MetricResult[] = metricQuery.result[0].data.map(result => {\n    return {\n      \"Service Name\": result.dimensionMap[\"dt.entity.service.name\"],\n      \"Service ID\": result.dimensionMap[\"dt.entity.service\"],\n      \"Failure Rate\": +result.values\n    };\n  });\n\n  return processedResults;\n}\n\nfunction buildQuery(inputs: string[], metricKey: string): string {\n  const filters = inputs.map(\n    input => `in(\"dt.entity.service\", entitySelector(\"type(service), entityName.equals(~\"${input}~\")\"))`\n  );\n  const filterString = filters.join(\",\");\n\n  return `${metricKey}:filter(or(${filterString})):splitBy(\"dt.entity.service\"):sort(value(auto, descending)):names`;\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"","autoscale":true},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"7":{"type":"code","title":"CPU Time (ms)","input":"/*\n * This function will run in the DYNATRACE JavaScript runtime.\n * For information, visit https://dt-url.net/functions-help\n */\nimport { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function fetchMetricResults() {\n  const serviceSelection = $service;\n  const metricKey = \"builtin:service.cpu.perRequest\";\n\n  const config = {\n    metricSelector: buildQuery(serviceSelection, metricKey),\n    resolution: \"Inf\",\n    from: $dt_timeframe_from,\n    to: $dt_timeframe_to,\n    acceptType: \"application/json; charset=utf-8\"\n  };\n\n  if (config.metricSelector.length > 3500) {\n    return \"Please select fewer services\";\n  }\n\n  const metricQuery = await metricsClient.query(config);\n\n  const processedResults = metricQuery.result[0].data.map(result => {\n    return {\n      \"Service Name\": result.dimensionMap[\"dt.entity.service.name\"],\n      \"Service ID\": result.dimensionMap[\"dt.entity.service\"],\n      \"Avg CPU Time (Ms)\": result.values / 1000\n    };\n  });\n\n  return processedResults;\n}\n\nfunction buildQuery(inputs: string[], metricKey: string): string {\n  const filters = inputs.map(\n    input => `in(\"dt.entity.service\", entitySelector(\"type(service), entityName.equals(~\"${input}~\")\"))`\n  );\n  const filterString = filters.join(\",\");\n\n  return `${metricKey}:filter(or(${filterString})):splitBy(\"dt.entity.service\"):sort(value(auto, descending)):names`;\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"","autoscale":true},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"8":{"type":"code","title":"Response Time (ms)","input":"/*\n* This function will run in the DYNATRACE JavaScript runtime.\n* For information visit https://dt-url.net/functions-help\n*/\nimport { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function () {\n\n  const metric_key = \"builtin:service.response.time\"\n  const service_selection = $service\n  const data_type = \"double\"\n\n  const config = {\n    metricSelector: buildQuery(service_selection, metric_key),\n    resolution: \"1m\",\n    from: $dt_timeframe_from,\n    to: $dt_timeframe_to,\n    acceptType: \"application/json; charset=utf-8\"\n  }\n\n  if (config.metricSelector.length > 3500) {\n    return (\"Please select fewer services\")\n  }\n  const metric_query = await metricsClient.query(config);\n\n  const data = metric_query.result[0].data\n  metric_query.result[0].data\n  data.forEach(obj => {\n    obj.values = obj.values.map(value => value === null ? 0 : value);\n  });\n\n  const mergedData: MergedData = {};\n\n  data.forEach((item) => {\n    const { dimensionMap, timestamps, values } = item;\n    const serviceName = dimensionMap[\"dt.entity.service.name\"];\n    const serviceId = dimensionMap[\"dt.entity.service\"]; // Assuming you have a service ID field in dimensionMap\n\n    timestamps.forEach((timestamp, index) => {\n      if (!mergedData[timestamp]) {\n        mergedData[timestamp] = {};\n      }\n      const serviceKey = `${serviceName} - ${serviceId}`; // Combine service name and ID to create a unique key\n      mergedData[timestamp][serviceKey] = values[index] / 1000;\n    });\n  });\n\n  const mappings = {\n    timestamp: { type: 'timestamp' },\n  };\n\n  for (const item of data) {\n    const serviceName = item.dimensionMap['dt.entity.service.name'];\n    const serviceId = item.dimensionMap[\"dt.entity.service\"];\n    const serviceKey = `${serviceName} - ${serviceId}`;\n\n    mappings[serviceKey] = { type: data_type };\n  }\n\n  const output = {\n    records: Object.entries(mergedData).map(([timestamp, services]) => ({\n      timestamp: parseInt(timestamp),\n      ...services,\n    })),\n    types: [\n      {\n        indexRange: [0, data[0].timestamps.length - 1],\n        mappings,\n      },\n    ],\n  };\n\n  return output\n\n}\n\nfunction combineData(input: any[]): any {\n  const records: any[] = [];\n  const mappings: any = {};\n\n  for (const item of input) {\n    const { dimensionMap, timestamps, values, dimensions } = item;\n\n    for (let i = 0; i < timestamps.length; i++) {\n      const timestamp = timestamps[i].toString();\n      const record: any = { timestamp };\n\n      for (let j = 0; j < dimensions.length; j++) {\n        const dimension = dimensions[j];\n        const value = values[i * dimensions.length + j];\n        record[dimension] = value || 0;\n\n        if (!mappings[dimension]) {\n          mappings[dimension] = { type: typeof value === 'number' ? 'double' : 'unknown' };\n        }\n      }\n\n      records.push(record);\n    }\n  }\n\n  const types: any[] = [{\n    indexRange: [0, records.length],\n    mappings\n  }];\n\n  return { records, types };\n}\n\nfunction buildQuery(inputs: string[], metricKey: string): string {\n  const filters = inputs.map(\n    input => `in(\"dt.entity.service\",entitySelector(\"type(service),entityName.equals(~\"${input}~\")\"))`\n  );\n  const filterString = filters.join(\",\");\n\n  return `${metricKey}:filter(or(${filterString})):splitBy(\"dt.entity.service\"):sort(value(auto,descending)):names`;\n}\n","visualization":"lineChart","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"","autoscale":true},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"9":{"type":"code","title":"Request Count","input":"/*\n* This function will run in the DYNATRACE JavaScript runtime.\n* For information visit https://dt-url.net/functions-help\n*/\nimport { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function () {\n\n  const metric_key = \"builtin:service.requestCount.total\"\n  const service_selection = $service\n  const data_type = \"double\"\n\n  const config = {\n    metricSelector: buildQuery(service_selection, metric_key),\n    resolution: \"10m\",\n    from: $dt_timeframe_from,\n    to: $dt_timeframe_to,\n    acceptType: \"application/json; charset=utf-8\"\n  }\n  if (config.metricSelector.length > 3500) {\n    return (\"Please select fewer services\")\n  }\n\n\n  const metric_query = await metricsClient.query(config);\n\n\n\n\n\n  const data = metric_query.result[0].data\n  data.forEach(obj => {\n    obj.values = obj.values.map(value => value === null ? 0 : value);\n  });\n\n\n  const mergedData: MergedData = {};\n\n  data.forEach((item) => {\n    const { dimensionMap, timestamps, values } = item;\n    const serviceName = dimensionMap[\"dt.entity.service.name\"];\n    const serviceId = dimensionMap[\"dt.entity.service\"];\n    timestamps.forEach((timestamp, index) => {\n      if (!mergedData[timestamp]) {\n        mergedData[timestamp] = {};\n      }\n      const serviceKey = `${serviceName} - ${serviceId}`;\n      mergedData[timestamp][serviceKey] = values[index];\n    });\n  });\n\n  const mappings = {\n    timestamp: { type: 'timestamp' },\n  };\n\n  for (const item of data) {\n    const serviceName = item.dimensionMap['dt.entity.service.name'];\n    const serviceId = item.dimensionMap[\"dt.entity.service\"];\n    const serviceKey = `${serviceName} - ${serviceId}`;\n\n    mappings[serviceKey] = { type: data_type };\n  }\n\n  const output = {\n    records: Object.entries(mergedData).map(([timestamp, services]) => ({\n      timestamp: parseInt(timestamp),\n      ...services,\n    })),\n    types: [\n      {\n        indexRange: [0, data[0].timestamps.length - 1],\n        mappings,\n      },\n    ],\n  };\n\n  return output\n\n  //const test = combineData(metric_datapoints);\n}\n\n\nfunction combineData(input: any[]): any {\n  const records: any[] = [];\n  const mappings: any = {};\n\n  for (const item of input) {\n    const { dimensionMap, timestamps, values, dimensions } = item;\n\n    for (let i = 0; i < timestamps.length; i++) {\n      const timestamp = timestamps[i].toString();\n      const record: any = { timestamp };\n\n      for (let j = 0; j < dimensions.length; j++) {\n        const dimension = dimensions[j];\n        const value = values[i * dimensions.length + j];\n        record[dimension] = value || 0;\n\n        if (!mappings[dimension]) {\n          mappings[dimension] = { type: typeof value === 'number' ? 'double' : 'unknown' };\n        }\n      }\n\n      records.push(record);\n    }\n  }\n\n  const types: any[] = [{\n    indexRange: [0, records.length],\n    mappings\n  }];\n\n  return { records, types };\n}\n\nfunction buildQuery(inputs: string[], metricKey: string): string {\n  const filters = inputs.map(\n    input => `in(\"dt.entity.service\",entitySelector(\"type(service),entityName.equals(~\"${input}~\")\"))`\n  );\n  const filterString = filters.join(\",\");\n\n  return `${metricKey}:filter(or(${filterString})):splitBy(\"dt.entity.service\"):sort(value(auto,descending)):names`;\n}","visualization":"lineChart","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"","autoscale":true},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[["timestamps"]]}}},"10":{"type":"code","title":"Error rate (Failures)","input":"/*\n* This function will run in the DYNATRACE JavaScript runtime.\n* For information visit https://dt-url.net/functions-help\n*/\nimport { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function () {\n\n  const metric_key = \"builtin:service.errors.total.rate\"\n  const service_selection = $service\n  const data_type = \"double\"\n\n  const config = {\n    metricSelector: buildQuery(service_selection, metric_key),\n    resolution: \"10m\",\n    from: $dt_timeframe_from,\n    to: $dt_timeframe_to,\n    acceptType: \"application/json; charset=utf-8\"\n  }\n  if (config.metricSelector.length > 3500) {\n    return (\"Please select fewer services\")\n  }\n\n\n  const metric_query = await metricsClient.query(config);\n\n\n\n\n\n  const data = metric_query.result[0].data\n  data.forEach(obj => {\n    obj.values = obj.values.map(value => value === null ? 0 : value);\n  });\n\n\n  const mergedData: MergedData = {};\n\n  data.forEach((item) => {\n    const { dimensionMap, timestamps, values } = item;\n    const serviceName = dimensionMap[\"dt.entity.service.name\"];\n    const serviceId = dimensionMap[\"dt.entity.service\"];\n    timestamps.forEach((timestamp, index) => {\n      if (!mergedData[timestamp]) {\n        mergedData[timestamp] = {};\n      }\n      const serviceKey = `${serviceName} - ${serviceId}`;\n      mergedData[timestamp][serviceKey] = values[index];\n    });\n  });\n\n  const mappings = {\n    timestamp: { type: 'timestamp' },\n  };\n\n  for (const item of data) {\n    const serviceName = item.dimensionMap['dt.entity.service.name'];\n    const serviceId = item.dimensionMap[\"dt.entity.service\"];\n    const serviceKey = `${serviceName} - ${serviceId}`;\n\n    mappings[serviceKey] = { type: data_type };\n  }\n\n  const output = {\n    records: Object.entries(mergedData).map(([timestamp, services]) => ({\n      timestamp: parseInt(timestamp),\n      ...services,\n    })),\n    types: [\n      {\n        indexRange: [0, data[0].timestamps.length - 1],\n        mappings,\n      },\n    ],\n  };\n\n  return output\n\n}\n\nfunction combineData(input: any[]): any {\n  const records: any[] = [];\n  const mappings: any = {};\n\n  for (const item of input) {\n    const { dimensionMap, timestamps, values, dimensions } = item;\n\n    for (let i = 0; i < timestamps.length; i++) {\n      const timestamp = timestamps[i].toString();\n      const record: any = { timestamp };\n\n      for (let j = 0; j < dimensions.length; j++) {\n        const dimension = dimensions[j];\n        const value = values[i * dimensions.length + j];\n        record[dimension] = value || 0;\n\n        if (!mappings[dimension]) {\n          mappings[dimension] = { type: typeof value === 'number' ? 'double' : 'unknown' };\n        }\n      }\n\n      records.push(record);\n    }\n  }\n\n  const types: any[] = [{\n    indexRange: [0, records.length],\n    mappings\n  }];\n\n  return { records, types };\n}\n\nfunction buildQuery(inputs: string[], metricKey: string): string {\n  const filters = inputs.map(\n    input => `in(\"dt.entity.service\",entitySelector(\"type(service),entityName.equals(~\"${input}~\")\"))`\n  );\n  const filterString = filters.join(\",\");\n\n  return `${metricKey}:filter(or(${filterString})):splitBy(\"dt.entity.service\"):sort(value(auto,descending)):names`;\n}","visualization":"lineChart","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"","autoscale":true},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[["timestamps"]]}}},"11":{"type":"code","title":"CPU Time (ms)","input":"/*\n* This function will run in the DYNATRACE JavaScript runtime.\n* For information visit https://dt-url.net/functions-help\n*/\nimport { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function () {\n\n  const metric_key = \"builtin:service.cpu.perRequest\"\n  const service_selection = $service\n  const data_type = \"double\"\n\n  const config = {\n    metricSelector: buildQuery(service_selection, metric_key),\n    resolution: \"10m\",\n    from: $dt_timeframe_from,\n    to: $dt_timeframe_to,\n    acceptType: \"application/json; charset=utf-8\"\n  }\n  if (config.metricSelector.length > 3500) {\n    return (\"Please select fewer services\")\n  }\n\n\n  const metric_query = await metricsClient.query(config);\n\n\n\n\n\n  const data = metric_query.result[0].data\n  data.forEach(obj => {\n    obj.values = obj.values.map(value => value === null ? 0 : value);\n  });\n\n\n  const mergedData: MergedData = {};\n\n  data.forEach((item) => {\n    const { dimensionMap, timestamps, values } = item;\n    const serviceName = dimensionMap[\"dt.entity.service.name\"];\n    const serviceId = dimensionMap[\"dt.entity.service\"];\n    timestamps.forEach((timestamp, index) => {\n      if (!mergedData[timestamp]) {\n        mergedData[timestamp] = {};\n      }\n      const serviceKey = `${serviceName} - ${serviceId}`;\n      mergedData[timestamp][serviceKey] = values[index] / 1000;\n    });\n  });\n\n  const mappings = {\n    timestamp: { type: 'timestamp' },\n  };\n\n  for (const item of data) {\n    const serviceName = item.dimensionMap['dt.entity.service.name'];\n    const serviceId = item.dimensionMap[\"dt.entity.service\"];\n    const serviceKey = `${serviceName} - ${serviceId}`;\n\n    mappings[serviceKey] = { type: data_type };\n  }\n\n  const output = {\n    records: Object.entries(mergedData).map(([timestamp, services]) => ({\n      timestamp: parseInt(timestamp),\n      ...services,\n    })),\n    types: [\n      {\n        indexRange: [0, data[0].timestamps.length - 1],\n        mappings,\n      },\n    ],\n  };\n\n  return output\n}\n\n\nfunction combineData(input: any[]): any {\n  const records: any[] = [];\n  const mappings: any = {};\n\n  for (const item of input) {\n    const { dimensionMap, timestamps, values, dimensions } = item;\n\n    for (let i = 0; i < timestamps.length; i++) {\n      const timestamp = timestamps[i].toString();\n      const record: any = { timestamp };\n\n      for (let j = 0; j < dimensions.length; j++) {\n        const dimension = dimensions[j];\n        const value = values[i * dimensions.length + j];\n        record[dimension] = value || 0;\n\n        if (!mappings[dimension]) {\n          mappings[dimension] = { type: typeof value === 'number' ? 'double' : 'unknown' };\n        }\n      }\n\n      records.push(record);\n    }\n  }\n\n  const types: any[] = [{\n    indexRange: [0, records.length],\n    mappings\n  }];\n\n  return { records, types };\n}\n\nfunction buildQuery(inputs: string[], metricKey: string): string {\n  const filters = inputs.map(\n    input => `in(\"dt.entity.service\",entitySelector(\"type(service),entityName.equals(~\"${input}~\")\"))`\n  );\n  const filterString = filters.join(\",\");\n\n  return `${metricKey}:filter(or(${filterString})):splitBy(\"dt.entity.service\"):sort(value(auto,descending)):names`;\n}","visualization":"lineChart","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"","autoscale":true},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[["timestamps"]]}}},"12":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"},"13":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"},"14":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"},"15":{"type":"markdown","title":"","content":"![](data:image/webp;base64,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)"},"17":{"type":"code","title":"Total Response Time (ms)","input":"import { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function fetchMetricResults() {\n  const serviceSelection = $service;\n  const metricKey = \"builtin:service.response.time\";\n\n  const config = {\n    metricSelector: buildQuery(serviceSelection, metricKey),\n    resolution: \"Inf\",\n    from: $dt_timeframe_from,\n    to: $dt_timeframe_to,\n    acceptType: \"application/json; charset=utf-8\"\n  };\n\n  if (config.metricSelector.length > 3500) {\n    return \"Please select fewer services\";\n  }\n\n  const metricQuery = await metricsClient.query(config);\n\n  const processedResults: MetricResult[] = metricQuery.result[0].data.map(result => {\n    return {\n      \"Service Name\": result.dimensionMap[\"dt.entity.service.name\"],\n      \"Service ID\": result.dimensionMap[\"dt.entity.service\"],\n      \"Avg Response Time (Ms)\": result.values / 1000\n    };\n  });\n\n//  return processedResults;\nlet sum = 0\nfor(const result of processedResults) {\nsum += +result[\"Avg Response Time (Ms)\"]\n}\n  return sum;\n}\n\nfunction buildQuery(inputs: string[], metricKey: string): string {\n  const filters = inputs.map(\n    input => `in(\"dt.entity.service\", entitySelector(\"type(service), entityName.equals(~\"${input}~\")\"))`\n  );\n  const filterString = filters.join(\",\");\n\n  return `${metricKey}:filter(or(${filterString})):splitBy(\"dt.entity.service\"):sort(value(auto,descending)):names`;\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":true},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[["service_name"]]}}},"18":{"type":"code","title":"Total Request Count (Throughput)","input":"/*\n * This function will run in the DYNATRACE JavaScript runtime.\n * For information, visit https://dt-url.net/functions-help\n */\nimport { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function fetchMetricResults() {\n  const serviceSelection = $service;\n  const metricKey = \"builtin:service.requestCount.total\";\n\n  const config = {\n    metricSelector: buildQuery(serviceSelection, metricKey),\n    resolution: \"Inf\",\n    from: $dt_timeframe_from,\n    to: $dt_timeframe_to,\n    acceptType: \"application/json; charset=utf-8\"\n  };\n\n  if (config.metricSelector.length > 3500) {\n    return \"Please select fewer services\";\n  }\n\n  const metricQuery = await metricsClient.query(config);\n\n  const processedResults = metricQuery.result[0].data.map(result => {\n    return {\n      \"Service Name\": result.dimensionMap[\"dt.entity.service.name\"],\n      \"Service ID\": result.dimensionMap[\"dt.entity.service\"],\n      \"Request Count\": result.values\n    };\n  });\n\n//  return processedResults;\nlet sum = 0\nfor(const result of processedResults) {\nsum += +result[\"Request Count\"]\n}\nreturn sum;\n}\n\nfunction buildQuery(inputs: string[], metricKey: string): string {\n  const filters = inputs.map(\n    input => `in(\"dt.entity.service\", entitySelector(\"type(service), entityName.equals(~\"${input}~\")\"))`\n  );\n  const filterString = filters.join(\",\");\n\n  return `${metricKey}:filter(or(${filterString})):splitBy(\"dt.entity.service\"):sort(value(auto, descending)):names`;\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[["service_name"]]}}},"19":{"type":"code","title":"Total CPU Time (ms)","input":"/*\n * This function will run in the DYNATRACE JavaScript runtime.\n * For information, visit https://dt-url.net/functions-help\n */\nimport { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function fetchMetricResults() {\n  const serviceSelection = $service;\n  const metricKey = \"builtin:service.cpu.perRequest\";\n\n  const config = {\n    metricSelector: buildQuery(serviceSelection, metricKey),\n    resolution: \"Inf\",\n    from: $dt_timeframe_from,\n    to: $dt_timeframe_to,\n    acceptType: \"application/json; charset=utf-8\"\n  };\n\n  if (config.metricSelector.length > 3500) {\n    return \"Please select fewer services\";\n  }\n\n  const metricQuery = await metricsClient.query(config);\n\n  const processedResults = metricQuery.result[0].data.map(result => {\n    return {\n      \"Service Name\": result.dimensionMap[\"dt.entity.service.name\"],\n      \"Service ID\": result.dimensionMap[\"dt.entity.service\"],\n      \"Avg CPU Time (Ms)\": result.values / 1000\n    };\n  });\n\n//  return processedResults;\nlet sum = 0\nfor(const result of processedResults) {\nsum += +result[\"Avg CPU Time (Ms)\"]\n}\n  return sum;}\n\nfunction buildQuery(inputs: string[], metricKey: string): string {\n  const filters = inputs.map(\n    input => `in(\"dt.entity.service\", entitySelector(\"type(service), entityName.equals(~\"${input}~\")\"))`\n  );\n  const filterString = filters.join(\",\");\n\n  return `${metricKey}:filter(or(${filterString})):splitBy(\"dt.entity.service\"):sort(value(auto, descending)):names`;\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":true},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[["service_name"]]}}},"20":{"type":"code","title":"Total Failure Rate (Failures)","input":"/*\n * This function will run in the DYNATRACE JavaScript runtime.\n * For information, visit https://dt-url.net/functions-help\n */\nimport { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function fetchMetricResults() {\n  const serviceSelection = $service;\n  const metricKey = \"builtin:service.errors.total.rate\";\n\n  const config = {\n    metricSelector: buildQuery(serviceSelection, metricKey),\n    resolution: \"Inf\",\n    from: $dt_timeframe_from,\n    to: $dt_timeframe_to,\n    acceptType: \"application/json; charset=utf-8\"\n  };\n\n  if (config.metricSelector.length > 3500) {\n    return \"Please select fewer services\";\n  }\n\n  const metricQuery = await metricsClient.query(config);\n\n  const processedResults: MetricResult[] = metricQuery.result[0].data.map(result => {\n    return {\n      \"Service Name\": result.dimensionMap[\"dt.entity.service.name\"],\n      \"Service ID\": result.dimensionMap[\"dt.entity.service\"],\n      \"Failure Rate\": result.values\n    };\n  });\n\n//  return processedResults;\nlet sum = 0\nfor(const result of processedResults) {\nsum += +result[\"Failure Rate\"]\n}\n  return sum;\n}\n\nfunction buildQuery(inputs: string[], metricKey: string): string {\n  const filters = inputs.map(\n    input => `in(\"dt.entity.service\", entitySelector(\"type(service), entityName.equals(~\"${input}~\")\"))`\n  );\n  const filterString = filters.join(\",\");\n\n  return `${metricKey}:filter(or(${filterString})):splitBy(\"dt.entity.service\"):sort(value(auto, descending)):names`;\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":true},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[["service_name"]]}}},"21":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"}},"layouts":{"0":{"x":12,"y":4,"w":12,"h":5},"1":{"x":0,"y":4,"w":12,"h":5},"6":{"x":0,"y":9,"w":12,"h":5},"7":{"x":12,"y":9,"w":12,"h":5},"8":{"x":0,"y":15,"w":24,"h":7},"9":{"x":0,"y":22,"w":24,"h":7},"10":{"x":0,"y":29,"w":24,"h":7},"11":{"x":0,"y":36,"w":24,"h":7},"12":{"x":0,"y":0,"w":24,"h":1},"13":{"x":0,"y":3,"w":24,"h":1},"14":{"x":0,"y":14,"w":24,"h":1},"15":{"x":0,"y":1,"w":8,"h":2},"17":{"x":8,"y":1,"w":4,"h":2},"18":{"x":12,"y":1,"w":4,"h":2},"19":{"x":20,"y":1,"w":4,"h":2},"20":{"x":16,"y":1,"w":4,"h":2},"21":{"x":0,"y":43,"w":24,"h":1}}}